TruePrototyping.js
==================

The javascript library which provides API for using True Prototypal Inheritance.



=== Slogan

Stop thinking with "classes" and "instances"! Think with true prototypal chain!

=== Traditional inheritance model is weird

Javascript is a propotype-based language. From the statement it could be expected javascript uses paradigm of Prototypal Inheritance. Unfortunately it is so and at the same time not quite so.

Sure javascript uses prototypes for inheritance. But traditional inheritance model in javascript mimics classical OOP instead of to be true Prototypal Inheritance (http://en.wikipedia.org/wiki/Prototype-based_programming). Using functions as object constructors with "new" operator and excurrent implementation of "prototype" and "constructor" properties, "typeof" and "instanceof" operators makes a program more complex and confusing than it can be.

A couple of links:
* Denunciation of the "traditional" style by Douglas Crockford: http://javascript.crockford.com/prototypal.html
* Confusion with "constructor" property: http://joost.zeekat.nl/constructors-considered-mildly-confusing.html


=== Ways of using true prototypal inheritance style

True prototypal inheritance style in javascript is possible for long time with using non-standard "__proto__" property. Since ECMAScript 5th Edition (JavaScript 1.8.5) there is a standard way for true prototypal inheritance style - Object.create and a few related methods.

So the idea is not new. A couple of links:
* Demonstration of the true style by Tim Caswell, a Node.js developer: http://howtonode.org/prototypical-inheritance
* My article (in Russian): http://innerbytes.net/proto/javascript/clear_prototipal_inheritance.htm


=== What I propose here

Actually I am annoyed by most of popular javascript libraries and frameworks not just use the "traditional" style, but even enhance imitation of Classical OOP with class-like APIs, while seems there is no library which follows the true prototypal inheritance style. I guess why it is so (see Problems section below), but I assume the "true style" deserves to be more used than it is at nowadays.

I try to achieve two aims:
1. To make "true" style programming as it possible compact and pleasing. I have mentioned ES5 standard intends a support of what I name the "true" style. As for me, the standard way is too verbose. So I propose some syntactical sugar.
2. To make "true" style programming possible in new (ES5-compliant) browsers as well as in old (not ES5-compliant) browsers with the same syntax.

=== Example of use

  Person = {
    ... // any properties
  };

  Employee = Person.derive({
    ... // any properties
  });

  var john = Employee.derive({
    name: "John",
    ... // any other properties
  });

Behind the scene, as well as on the scene, there is a +chain of delegation containing only the objects you've defined+ and nothing more:
  Employee.ancestor == Person // Employee.__proto__ == Person
  john.ancestor == Employee   // john.__proto__ == Employee

There is no mystical "prototype", which exists regardless you haven't defined it and replacement of which can break object relationship at all.


=== Problems with the "true" prototypal inheritance style

As for me the proposed approach is great, if you use it in some program system from the scratch. But it can be confusing, if you try to use some "traditionally" designed libraries with the new approach. At least in this case you cannot abstract from the old way and think with the new way only. Furthermore using "old library" with the new way can break correct working of the library at all.

Example:

Suppose some library has Person "class" and the official way of using the class is following:

  var john = new Person("John");

The official way of deriving from the "class" is following:

  Employee = Person.extend();
  var john = new Employee("John");

Perhaps the library provides some API around the Person "class" and the API and the API implementation likely relies on john.__proto__ should point to Employee.prototype.

If you use the proposed new way to make Employee (what is more clear as for me):

  Employee = Person.derive();
  var john = Employee.derive("John");

john.__proto__ will point to Employee itself instead of Employee.prototype and the library will likely break because that.


=== TODO

* Implementation for an environment which is not ES5-compliant.
* Maybe it makes sense to implement "super" without necessity to pass ancestor's method name as a first argument. Benefit of the current implementation is only that it is very simple and, at the same time, allows calling any ancestor's method, not the exactly "super" in traditional meaning.
