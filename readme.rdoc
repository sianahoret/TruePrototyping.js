== TruePrototyping.js

The javascript library which provides API for using True Prototypal Inheritance.



=== Slogan

Stop thinking with "classes" and "instances" - think with true prototype chain, just a chain of delegation!


=== Traditional inheritance model is weird

Javascript is a propotype-based language. From the statement it could be expected javascript uses paradigm of Prototypal Inheritance. Unfortunately it is so and at the same time not quite so.

Sure javascript uses prototypes for inheritance. But traditional inheritance model in javascript mimics classical OOP instead of to be {True Prototypal Inheritance}[http://en.wikipedia.org/wiki/Prototype-based_programming]. Using functions as object constructors with "new" operator and excurrent implementation of "prototype" and "constructor" properties, "typeof" and "instanceof" operators makes a program more complex and confusing than it can be.

A couple of links:
* {Denunciation of the "traditional" style by Douglas Crockford}[http://javascript.crockford.com/prototypal.html]
* {Confusion with "constructor" property}[http://joost.zeekat.nl/constructors-considered-mildly-confusing.html]


=== Ways of using true prototypal inheritance style

True prototypal inheritance style in javascript is possible for long time with using non-standard "__proto__" property. Since ECMAScript 5th Edition (JavaScript 1.8.5) there is a standard way for true prototypal inheritance style - Object.create and a few related methods.

So the idea is not new. A couple of links:
* {Demonstration of the true style by Tim Caswell, a Node.js developer}[http://howtonode.org/prototypical-inheritance]
* {My article (in Russian)}[http://innerbytes.net/proto/javascript/clear_prototipal_inheritance.htm]


=== What I propose here

Actually I am upset by most of popular javascript libraries and frameworks not just use the "traditional" style, but even enhance imitation of Classical OOP with class-like APIs, while seems there is no library which follows the true prototypal inheritance style. I guess why it is so (see Problems section below), but I assume the "true style" deserves to be more used than it is at nowadays.

I try to achieve two aims:
1. To make "true" style programming as it possible compact and pleasing. I have mentioned ES5 standard intends a support of what I name the "true" style. As for me, the standard way is too verbose. So I propose some syntactical sugar.
2. To make "true" style programming possible in new (ES5-compliant) browsers as well as in old (not ES5-compliant) browsers with the same syntax.


=== Using

After you include the TruePrototyping.js into your program, you can construct inheritance chain in the following way:

  Person = {
    ... // some properties
  };

  Employee = Person.derive({
    ... // some Employee specific properties
  });

  var john = Employee.derive({
    name: "John",
    ... // some john specific properties
  });

<b>Behind the scene, as well as on the scene, there is a chain of delegation containing only the objects you've defined</b> and nothing more:
  Employee.ancestor == Person // Employee.__proto__ == Person
  john.ancestor == Employee   // john.__proto__ == Employee

There is no mystical "prototype", which exists regardless you haven't defined it and {replacement of which can break object relationship at all}[http://joost.zeekat.nl/constructors-considered-mildly-confusing.html].

And what? What are the benefits excepting "background cleanness"?

Well, the simplest benefit is following. Suppose having any object in program, you want to make almost similar object, but slightly different. With the proposed approach you can derive new object from the existing, not worrying about nature of the existing object (existing object can be Function or not, can have proper "prototype" or "constructor" property or do not have one):

  someExistingObject.method1(); // suppose returns "method1"

  myObject = someExistingObject.derive({   // type of someExistingObject does not matter
    method2: function(){
      return "method2";
    };
  });

  myObject.method1(); // returns "method1"
  myObject.method2(); // returns "method2"


=== Caution about 'derive'

Unfortunately there is a problem with the proposed "true" prototypal inheritance style.

I treat the approach as straightforward and clear, if you use it in some program system from the scratch.

However the approach can be confusing, if you try to mix it with the "traditional" way. At least you cannot completely abstract from the old way and think with the new way only, you should be careful with such mix.

For example, traditionally you use Backbone.Model in this way:

  var MyModel = Backbone.Model.extend({});
  var myInstance = new MyModel(); // myInstance is traditional "instanceof" MyModel

If you try to do this:

  var MyModel = Backbone.Model.extend({});
  var myInstance = MyModel.derive();  // myInstance.__proto__ points to MyModel itself instead of MyModel.prototype

myInstance object won't act as expected for an instance of Backbone.Model, because myInstance is not traditional "instanceof" MyModel (and is not "instanceof" Backbone.Model), what the Backbone framework relies on.


=== Partial using

Even if due to caution have been mentioned above you do not use 'derive', but use the "traditional" inheritance way, the 'ancestor', 'ancestors', 'super', 'isAncestorOf', 'isDescendantOf' properties and methods still can be useful for inspecting and walking through true prototype chain.

For example, you have your custom Backbone Model (MyModel) and you want to override 'url' method for MyModel "class" with using base implementation of the method. How to get the base implementation? The {commonly used way}[http://backbonejs.org/#Model-extend] is following:

  var MyModel = Backbone.Model.extend({
    urlRoot : '/users',

    id: "ID",

    url: function(){
      return Backbone.Model.prototype.url.call(this) + '/somethingExtra';
      // return this.constructor.__super__.url.call(this) + '/somethingExtra'; // actually Backbone has undocumented __super__, but other frameworks may not have it
    }
  });

  var myInstance = new MyModel();

  myInstance.url(); // result is "/users/ID/somethingExtra"

That is, you have to use explicit "Backbone.Model.prototype" notation to access the object which keeps base implementation of Backbone.Model instance properties.
What to do, if you do not like to explicitly refer to Backbone.Model, but you prefer to refer to an ancestor without use of its constructor name? You can do that with using 'ancestor' and 'super' from the TruePrototyping library:

  var MyModel = Backbone.Model.extend({
    urlRoot : '/users',

    id: "ID",

    url: function(){
      return this.ancestor.super('url') + '/somethingExtra'; // this will work in any hierarchy, not in Backbone only (TODO: make example with Mootols or Prototype)
    },
  });

  var myInstance = new MyModel();

  myInstance.url(); // result is "/users/ID/somethingYouWant"

What you only should remember is that this.ancestor === MyModel.prototype. Well, if 'this.ancestor' construction in this sense looks confusing, you can keep this.ancestor value in some other property to make the code more clear for you.

  var MyModel = Backbone.Model.extend({
    myPrototype: function() { return this.ancestor }, // "traditional" keeper of MyModel instance properties

    urlRoot : '/users',

    id: "ID",

    url: function(){
      return this.myPrototype().super('url') + '/somethingExtra';
    }
  });

  var myInstance = new MyModel();

  myInstance.url(); // result is "/users/ID/somethingExtra"


=== TODO

* Implementation for an environment which is not ES5-compliant.
* Maybe it makes sense to implement "super" without necessity to pass ancestor's method name as a first argument. Benefit of the current implementation is only that it is very simple and, at the same time, allows calling any ancestor's method, not the exactly "super" in traditional meaning.
